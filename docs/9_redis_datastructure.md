# 🎤 콘서트 예약 서비스

## 📝 프로젝트 개요

이 프로젝트는 콘서트 예약 서비스를 위한 대기열 시스템을 설계하는 것입니다.
사용자는 대기열에 등록하고, 좌석을 점유하며, 결제를 통해 좌석 소유권을 획득할 수 있습니다.
이 시스템은 동시성 제어, 상태 기반 흐름 제어, 무결성 보장 등을 고려하여 설계하였습니다.

## 📚 설계 문서
- [요구사항 분석](1_requirements.md)
- [ERD](2_erd.md)
- [시퀀스 다이어그램](3_sequence_diagram.md)
- [상태 다이어그램](4_state_diagram.md)
- [API 명세](https://joyseohee.github.io/hhplus-concert-server)
- [DB 성능 보고서](5_db_report.md)
### 동시성 문제 보고서
- [동시성 이슈 : DB Lock 보고서](6_db_race_condition_report.md)
- [동시성 이슈 : 분산락 보고서](7_redis_distributed_lock_report.md)
### 캐시 전략 보고서
- [캐시 전략 보고서](8_redis_cash_report.md)
### 레디스 저장소 보고서
- [자료구조를 활용한 랭킹 시스템, 비동기 시스템 설계 및 구현 보고서](9_redis_datastructure.md)
- [도메인 분리 이후 트랜잭션 처리 전략 및 한계 분석](10_edd_transaction_doc.md)
- [이벤트 호출 로직 시퀀스 다이어그램](11_event_call_sequence_diagram.md)


# 📑 STEP 13 보고서 – 인기 콘서트 랭킹 시스템

## 1. 배경

* 사용자들은 어떤 콘서트가 가장 인기가 높은지 빠르게 확인할 수 있어야 함.
* 기존 RDBMS 기반 집계는 매번 `COUNT`/`GROUP BY` 연산이 필요해 부하가 큼.
* 따라서 **부하 없이 예약 수를 집계하고 랭킹을 제공**할 수 있는 인메모리 기반 구조가 필요.

---

## 2. 구현 방식

* **자료구조**: Redis **Sorted Set (ZSET)**
* **Key**: `popular:concert`
* **Value(member)**: `concertId`
* **Score**: 예약 수 (예약 발생 시 `ZINCRBY 1 popular:concert {concertId}`)

### 주요 동작

* 예약 발생 시 → `ZINCRBY` 로 해당 콘서트의 점수 증가
* 인기 순위 조회 → `ZREVRANGE popular:concert 0 9 WITHSCORES` (상위 10개 콘서트)

---

## 3. Sorted Set 선택 이유

### 다른 자료구조와 비교

| 자료구조                | 장점                                                       | 단점                                |
| ------------------- | -------------------------------------------------------- | --------------------------------- |
| **String**          | 단순 카운트 증가(`INCR`)에 최적화, O(1) 연산                          | 콘서트별 구분 필요 → Key 폭발, 전체 랭킹 집계 불가능 |
| **Hash**            | `{concertId → count}` 단순 매핑으로 관리 용이                      | 전체 순위 계산 불가 → 별도 정렬 연산 필요         |
| **List**            | 순서 기반 push/pop 효율적, 큐/스택 구조 적합                           | 특정 콘서트 점수 증가/랭킹 집계 비효율적           |
| **Set**             | 중복 없는 집합 관리 가능                                           | 점수/순위 개념 없음, 랭킹 불가능               |
| **Sorted Set (선택)** | 자동 정렬 + Score 증감(`ZINCRBY`) 지원, `ZREVRANGE`로 즉시 랭킹 조회 가능 | 메모리 사용량은 상대적으로 증가                 |

결론: 단순 카운트 목적이면 String/Hash도 가능하나, 랭킹 집계 요구사항 때문에 Sorted Set이 최적.

---

## 4. 개선 필요성 (트랜잭션 처리)

* 현재는 예약 시점마다 바로 `ZINCRBY` 로 점수를 증가.
* 하지만 실제 예약 로직에는 **결제/좌석 확정** 등의 트랜잭션이 포함.
* 예약 트랜잭션이 실패했는데 점수는 이미 증가하면 → **정합성 깨짐** 발생
* 따라서 **트랜잭션 경계**를 명확히 해야 함:

    * 예약 완료 → 최종 커밋 이후에만 `ZINCRBY` 수행
    * 또는 Redis 작업을 메시지 큐/비동기 이벤트로 분리하여 **DB 커밋 성공 시에만 점수 반영**

---

## 5. 결론

* Redis Sorted Set을 활용하여 인기 콘서트 랭킹을 효율적으로 구현.
* Hash, List, Set 대비 **순위 계산과 실시간 집계에 특화**된 ZSET이 가장 적합.
* 다만 예약 트랜잭션과 집계 반영 시점이 분리되지 않으면 정합성 문제가 발생할 수 있으며, 향후에는 **트랜잭션 경계 내 처리 또는 비동기 이벤트 기반 집계 반영**으로 개선해야 함.


---

# STEP 14. Asynchronous Design – Redis 대기열 요약 보고서

## 1. 배경

* 기존 RDBMS 기반 대기열은 **순번 계산/갱신 부하**와 **만료 처리 지연**으로 대규모 트래픽 대응에 한계.
* 사용자는 즉시 순번·상태를 확인하고, 시스템은 일정 단위(예: 50명)로 활성화해야 하는 요구 존재.

---

## 2. 구현 방식

* **Redis Sorted Set(ZSET) 2개만 활용**

    * `queue:waiting` : 대기열 (score=진입시각)
    * `queue:active`  : 활성열 (score=활성화시각)
* **만료 처리**: TTL 대신 `ZRANGEBYSCORE` 기반 시각 cut-off.
* **비동기 워커**: 주기적으로 상위 50명 이동(waiting → active).
* **API 일관성 유지**: 기존 `QueueService` 인터페이스를 유지하고 Repository만 Redis 기반으로 교체.

### 주요 동작

1. **대기열 진입**: `ZADD queue:waiting userId now`
2. **상태 확인**:

    * ACTIVE: `ZSCORE queue:active`
    * WAITING: `ZSCORE queue:waiting` + `ZRANK`, `ZCOUNT`로 순번 계산
3. **비동기 활성화**: 워커가 만료자 제거 후 상위 50명 이동
4. **예약 완료**: `ZREM queue:active userId`

### 효과

* **고성능**: `ZSCORE`, `ZRANK`, `ZCOUNT` 등 경량 연산 기반, 수만 동시 접속에도 빠른 응답.
* **단순성**: 키 최소화(2개)로 관리 용이, 시각 기반 만료로 TTL 관리 불필요.
* **안정성**: DIP 적용으로 도메인 로직 보호, 멱등성 보장으로 워커 중단/재시작에도 안전.

---
## 3. 자료구조 비교

| 자료구조                | 장점                                                    | 단점                             |
| ------------------- |-------------------------------------------------------|--------------------------------|
| **String**          | 단순 상태 저장(`userId:active`)에 용이, TTL 설정 가능              | 순번/정렬 불가, 전체 수 집계 어려움          |
| **Hash**            | 사용자별 속성(만료시간, 상태) 관리 용이                               | TTL을 각 필드 단위로 주기 어려움, 순번 계산 불가 |
| **List**            | FIFO 대기열 표현 자연스러움                                     | 중간 순번 조회 불가, 대규모 순번 조회 시 비효율   |
| **Set**             | 중복 없는 유저 관리 가능                                        | 순서·점수 없음 → 대기열 불가              |
| **Sorted Set (선택)** | 점수 기반 정렬로 순번/만료 관리 가능, `ZRANK`로 순번 조회, `ZREM`으로 만료 처리 | 구현 복잡도 약간 증가                   |

결론: 대기열 특성(순번 + 만료 + 활성화 그룹 관리) 때문에 Sorted Set이 가장 적합.

---

## 4. 개선 필요성

* **정확한 즉시 만료 한계**: TTL을 직접 스케줄러로 관리하다보니 주기 간격에 따라 만료 반영 시점 차이 발생.

---

## 5. 결론

* RDB 기반 대기열을 **Redis 기반 비동기 구조**로 전환하여, **실시간성·확장성·단순성**을 확보.
* Sorted Set 활용으로 효율적인 **순번 계산과 만료 처리 가능**.

