# 🎤 콘서트 예약 서비스

## 📝 프로젝트 개요

이 프로젝트는 콘서트 예약 서비스를 위한 대기열 시스템을 설계하는 것입니다.
사용자는 대기열에 등록하고, 좌석을 점유하며, 결제를 통해 좌석 소유권을 획득할 수 있습니다.
이 시스템은 동시성 제어, 상태 기반 흐름 제어, 무결성 보장 등을 고려하여 설계하였습니다.

## 📚 설계 문서
- [요구사항 분석](1_requirements.md)
- [ERD](2_erd.md)
- [시퀀스 다이어그램](3_sequence_diagram.md)
- [상태 다이어그램](4_state_diagram.md)
- [API 명세](https://joyseohee.github.io/hhplus-concert-server)
- [DB 성능 보고서](5_db_report.md)
### 동시성 문제 보고서
- [동시성 이슈 : DB Lock 보고서](6_db_race_condition_report.md)
- [동시성 이슈 : 분산락 보고서](7_redis_distributed_lock_report.md)
### 캐시 전략 보고서
- [캐시 전략 보고서](8_redis_cash_report.md)
### 레디스 저장소 보고서
- [자료구조를 활용한 랭킹 시스템, 비동기 시스템 설계 및 구현 보고서](9_redis_datastructure.md)

## 📄 분산락 적용 보고서 (STEP 11)

### 🎯 과제 목표

* **분산 환경에서의 동시성 문제**를 Redis 기반의 분산락으로 제어
* 트랜잭션 단위가 아닌, **작업 단위로 Lock 범위를 명확히 지정**
* DB Lock의 한계와 부하를 줄이고, **Redisson 기반의 경량 락**을 도입

---

## 🧩 문제 배경

콘서트 좌석 예약 시스템은 다음과 같은 특성상 동시성 충돌이 쉽게 발생합니다:

* 동일한 좌석에 대해 **여러 사용자가 동시에 점유 요청**
* **포인트 충전 및 결제 요청이 동시에 발생** 가능
* RDB의 Lock은 다른 목적으로 테이블에 접근하더라도 row나 테이블 단위로 Lock을 걸어버리므로 범위나 비용이 큼
* RDB 락의 **성능 저하 우려**를 방지하기 위해 **분산락 도입**

---

## 🧪 해결 전략 요약

| 전략 항목        | 설명                                                  |
| ------------ |-----------------------------------------------------|
| 🔑 락 키 설계    | 점유 자원의 고유성을 보장하도록 `concertId + seatId`, `userId` 로 설정 |
| 🔒 락 범위      | **비즈니스 작업 단위**로 설정 (예: 좌석 점유)           |
| 🔃 락-트랜잭션 순서 | 락 선점 → 트랜잭션 시작 → 처리 → 트랜잭션 종료 → 락 해제                |
| 🧪 테스트       | 동시 요청 테스트에서 충돌 및 중복 점유 방지를 확인 (Latch, Kotest 활용)    |

---

## ✅ 분산락 적용 상세

| 유즈케이스                                          | 락 키                              | 적용 대상  | 적용 이유                                                                                                                  |
| ---------------------------------------------- | -------------------------------- | ------ | ---------------------------------------------------------------------------------------------------------------------- |
| `HoldSeatUseCase.holdSeat`                     | `lock:seat:{concertId}:{seatId}` | 좌석 점유  | - 좌석은 단일 자원이므로, **중복 점유 방지**를 위해 좌석 단위로 락을 적용<br>- 좌석 점유 정보는 **RDB에 영속화**되므로, 이후 예약 확정 시에는 락 없이도 일관성 검증 가능             |
| `ConfirmReservationUseCase.confirmReservation` | `lock:user:{userId}:balance`     | 사용자 잔액 | - **잔액 차감 시점에만 충돌 가능성**이 존재하므로 사용자 단위로 락 적용<br>- 좌석 점유는 이미 RDB에서 확인 가능하며, 점유 만료가 되었더라도 트랜잭션 시작 시점의 **유효성만 보장되면 문제 없음** |
| `ChargeBalanceUseCase.chargeBalance`           | `lock:user:{userId}:balance`     | 포인트 충전 | - 동일한 사용자에게 여러 충전 요청이 동시에 들어올 수 있으므로 **중복 충전 방지**를 위해 사용자 단위 락 필요                                                      |

---

## 🔄 트랜잭션 & 락 처리 순서

* 락은 트랜잭션 **외부에서 선점**
* 이후 트랜잭션 내부 로직을 실행
* Redisson의 `tryLock()`은 동기 블로킹 방식으로 처리되며, **재시도 시에도 락 선점부터 다시 시도**

```kotlin
for (attempt in 0..maxRetries) {
    try {
        return redisLockManager.withLock(key, waitTimeMs, leaseTimeMs) {
            pjp.proceed() // 트랜잭션 역시 재 획득해 시도
        }
    } catch (e: Exception) {
        if (e is LockAcquireException && attempt < maxRetries) {
            Thread.sleep(retryDelayMs)
            continue
        }
        throw e
    }
}
```

> ✅ `@Order(HIGHEST_PRECEDENCE)` 설정을 통해 `@Transactional`보다 **락 AOP가 먼저 실행**되도록 구성

---

## 🧪 테스트 & 검증

* `CountDownLatch` 기반 동시성 테스트 수행
* 의도적으로 동일 자원에 대한 요청을 충돌시켜, **락 선점/재시도 동작 검증**
* **금전적 이득이 발생하는 경우만 재시도 대상**으로 제한 (예: 잔액 차감, 좌석 확정)

---

## 🔍 한계 및 고려사항

* **락 유지 시간 설정에 유의**: 너무 짧으면 작업 중간 실패, 너무 길면 리소스 낭비
* 락 범위를 최소화함으로써 **성능 병목 최소화**에 집중
* **좌석 점유는 현재 RDB에 저장**되지만, 추후 Redis로 source of truth를 전환하는 것도 고려 중 (히스토리 불필요한 단기 데이터이기 때문)

---

## 🧠 결론

* **DB Lock의 한계를 Redis 기반 락으로 보완**
* **트랜잭션과 분산락의 순서를 고려하되 분리**함으로써 예측 가능한 동시성 제어 달성
* 좌석 점유 → 예약 확정 → 잔액 처리 흐름 전체에서, **최소한의 락 적용으로 성능과 정합성 모두 확보**