# 🎤 콘서트 예약 서비스

## 📝 프로젝트 개요

이 프로젝트는 콘서트 예약 서비스를 위한 대기열 시스템을 설계하는 것입니다.
사용자는 대기열에 등록하고, 좌석을 점유하며, 결제를 통해 좌석 소유권을 획득할 수 있습니다.
이 시스템은 동시성 제어, 상태 기반 흐름 제어, 무결성 보장 등을 고려하여 설계하였습니다.

## 📚 설계 문서
- [요구사항 분석](1_requirements.md)
- [ERD](2_erd.md)
- [시퀀스 다이어그램](3_sequence_diagram.md)
- [상태 다이어그램](4_state_diagram.md)
- [API 명세](https://joyseohee.github.io/hhplus-concert-server)
- [DB 성능 보고서](5_db_report.md)
### 동시성 문제 보고서
- [동시성 이슈 : DB Lock 보고서](6_db_race_condition_report.md)
- [동시성 이슈 : 분산락 보고서](7_redis_distributed_lock_report.md)
### 캐시 전략 보고서
- [캐시 전략 보고서](8_redis_cash_report.md)
### 레디스 저장소 보고서
- [자료구조를 활용한 랭킹 시스템, 비동기 시스템 설계 및 구현 보고서](9_redis_datastructure.md)
- [도메인 분리 이후 트랜잭션 처리 전략 및 한계 분석](10_edd_transaction_doc.md)
- [이벤트 호출 로직 시퀀스 다이어그램](11_event_call_sequence_diagram.md)
### 카프카 설계 문서
- [카프카 기초 학습 및 활용](12_kafka.md)
### 부하테스트
- [카프카 부하 테스트](13_load_test.md)


## 📄 Redis 캐싱 전략 및 적용 여부 판단 문서 (STEP 12)

### 🎯 과제 목표
- 트래픽이 많은 API나 DB 부하가 높은 조회 로직에 대해 캐싱을 통해 성능을 개선합니다.
- 캐시 적용 방식(예: Read-Through, Cache Aside 등)과 적절한 Expiration / Eviction 전략을 설계하고 문서화합니다.
- **Cache Stampede(동시 캐시 부재)** 이슈에 대해 학습하고, 대응 전략을 설계합니다.

### 📢 문서 작성 목적
* Redis를 활용한 캐싱 전략에 관해 학습한 내용을 정리하고
* 우리 시스템에서 **왜 캐시를 적용하지 않았는지** 기술합니다.

---

## 📦 Redis 캐싱 전략 요약

Redis는 빠른 읽기 성능을 제공하는 **인메모리 키-값 저장소**로, 다음과 같은 캐싱 전략을 지원합니다.

### ✅ 주요 캐싱 전략

| 전략                             | 설명                                      | 예시                 |
| ------------------------------ | --------------------------------------- | ------------------ |
| **Cache Aside (Lazy-loading)** | 읽기 요청 시 Redis에 없으면 DB에서 조회 후 Redis에 저장  | 사용자 프로필, 게시글 상세 조회 |
| **Write Through**              | 쓰기 요청이 Redis와 DB에 동시에 반영                | 쇼핑몰 장바구니, 실시간 데이터  |
| **Read Through**               | 애플리케이션이 Redis에만 요청하고 Redis가 DB에서 알아서 채움 | 복잡한 로직을 단순화할 때     |
| **Write Behind**               | Redis에만 쓰고, 일정 시간마다 배치로 DB 반영           | 로그 저장, 비실시간 통계     |

### ✅ TTL 전략

* Redis는 \*\*TTL(Time-To-Live)\*\*을 설정하여 자동 만료가 가능함 → 실시간성이 낮고 일정 시간 동안 유효한 데이터에 적합
* 예: 인기 상품 목록, 최근 게시물 캐시 등

---

## 🎯 캐싱 미적용 판단 근거

현재 콘서트 좌석 예약 시스템의 주요 시나리오는 다음과 같습니다:

1. **좌석 점유 요청**: 사용자 간 중복 점유 방지가 중요함 → 분산락 + RDB 저장으로 처리
2. **좌석 예약 확정**: 가격, 좌석 상태, 포인트 잔액 등 정확성 필수
3. **좌석 목록 조회 및 좌석 예약 가능 여부 조회** : 쓰기 작업이 많고 최신 정보가 중요하므로 캐싱보다는 DB 정합성 우선
4. **포인트 충전/차감**: 동시성 제어 및 원자성 중요 → 캐싱보다 DB 정합성 우선
5. **큐 대기 및 토큰 활성화**: 짧은 생명주기의 write-heavy 데이터 → TTL 만료와 원자성 처리 중심

### 📌 캐싱이 적합하지 않은 이유

| 항목                 | 이유                                                                         |
| ------------------ |----------------------------------------------------------------------------|
| **쓰기 비율이 높음**      | 좌석 점유, 예약 확정, 포인트 충전 등 대부분이 write 중심 작업                                    |
| **정합성이 중요함**       | 최신 상태를 기준으로 점유 가능 여부, 잔액 여부를 판단해야 함                                        |
| **RDB 접근 비용이 낮음**  | 조회 대상이 대부분 단건이거나 목록의 경우에도 별다른 join 없이 PK 기반으로 조회해 이미 성능이 좋음                |
| **TTL 관리 필요 없음**   | 현 구현 단계 상으로 대부분의 데이터는 명시적 저장/삭제로 관리되며, 주기적인 캐시 만료 필요 없음. |
| **동시성 제어 중심 시나리오** | 읽기 속도보다 락과 트랜잭션 정합성이 더 중요한 과제                                              |

---

## 🧠 결론

* Redis 기반 캐싱 전략은 성능 최적화에 매우 유용하지만, **정합성이 중요한 트랜잭션 중심의 도메인**에서는 오히려 부적절할 수 있음
* 현재 과제에서는 캐싱보다 **분산락을 통한 동시성 제어와 트랜잭션 내 처리의 안정성 확보**가 더 중요
* 추후 다음과 같은 경우에는 캐싱 전략을 적용해볼 수 있음:

    * 인기 좌석 등과 같은 **빈번한 읽기 전용 데이터**
    * 예약 상태 통계 등 **실시간성이 낮은 집계 데이터**
    * 사용자 토큰/큐 상태 등의 **경량화된 세션 관리 데이터**
    * 좌석 점유 상태와 같은 **짧은 생명주기의 데이터** 등을 RDB에서 Redis로 이전하여 성능을 개선할 수 있음