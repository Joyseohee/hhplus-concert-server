# 🎤 콘서트 예약 서비스

## 📝 프로젝트 개요

이 프로젝트는 콘서트 예약 서비스를 위한 대기열 시스템을 설계하는 것입니다.
사용자는 대기열에 등록하고, 좌석을 점유하며, 결제를 통해 좌석 소유권을 획득할 수 있습니다.
이 시스템은 동시성 제어, 상태 기반 흐름 제어, 무결성 보장 등을 고려하여 설계하였습니다.

## 📚 설계 문서
- [요구사항 분석](1_requirements.md)
- [ERD](2_erd.md)
- [시퀀스 다이어그램](3_sequence_diagram.md)
- [상태 다이어그램](4_state_diagram.md)
- [API 명세](https://joyseohee.github.io/hhplus-concert-server)
- [DB 성능 보고서](5_db_report.md)
### 동시성 문제 보고서
- [동시성 이슈 : DB Lock 보고서](6_db_race_condition_report.md)
- [동시성 이슈 : 분산락 보고서](7_redis_distributed_lock_report.md)


## 1. 배경 (Background)

* **시스템 개요**

    * 콘서트 예약 시스템: 토큰 발급 → 좌석 점유 → 예약 확정 → 결제/충전 흐름
* **운영 환경 및 가정**

    * MySQL 8.x, InnoDB, 격리 수준: Repeatable Read
    * 스케줄러 주기: 1분
* **목적**

    * 주요 동시성 시나리오 식별
    * RDB 수준의 안전·고성능 보장

## 2. 문제 (Problem)

1. **동일 좌석 동시 점유**
2. **점유 만료 후 예약 경쟁**
3. **토큰 활성화 경쟁**
4. **토큰 만료와 사용 경쟁**
5. **잔액 충전 동시 업데이트**
6. **잔액 차감 (예약 확정 시)**
7. **충전 ↔ 차감 혼합 요청**

* **영향**: 중복 점유, 잔액 이상, 대기열 순서 뒤바뀜, 퍼포먼스 저하, 데드락 등

## 3. 해결방법 (Solution)

> **MySQL InnoDB Repeatable Read** 환경에서
>
> * **필요할 때만** 비관적 락으로 순서 보장
> * **나머지는** 낙관적 락+재시도로 최소 블로킹
> * **DB 제약·쿼리 필터링**으로 단순·효율적 제어

1. **동일 좌석 동시 점유**

    * **해결**: `UNIQUE(concert_id, seat_id)` 제약
    * **이유**: DB가 원자적으로 중복 차단 → 별도 락·트랜잭션 불필요

2. **점유 만료 후 예약 경쟁**

    * **해결**:

        * 로직 내 “만료 여부 확인 → `throw Exception`”
        * `@Retryable(ObjectOptimisticLockingFailureException)` 재시도
    * **이유**: DB 락 없이 충돌 해결, 일관성 보장

3. **토큰 활성화 경쟁**

    * **해결**: `SELECT … FOR UPDATE` / `@Lock(PESSIMISTIC_WRITE)`
    * **이유**: row 단위 락으로 순차 처리 보장

4. **토큰 만료와 사용 경쟁**

    * **해결**: 검증 시 `WHERE status='ACTIVE' AND expiresAt>NOW()`
    * **이유**: 단일 쿼리로 안전 체크, 락 불필요

5. **잔액 충전 동시 업데이트**

    * **해결**: `@Version` (낙관적 락) + `@Retryable(...)` 재시도
    * **이유**: 비즈니스에 유익한 금전 거래는 재시도, 적은 횟수(3회) 재시도로 높은 처리량

6. **잔액 차감 (예약 확정 시)**

    * **해결**:

        * `@Version` (낙관적 락) + `@Retryable(...)` 재시도
        * 예약 전 `validateQueueTokenService`로 토큰 유효성 검사
    * **이유**: 중복 차감 차단, 즉시 실패 처리

7. **충전 ↔ 차감 혼합 요청**

    * **해결**: 양쪽 모두 `@Version` + 재시도
    * **이유**: 순서 무관 처리, deadlock 위험 적음

## 4. 한계점 (Limitations)

* 극도로 많은 요청이 한번에 들어올 경우 요청이 누락될 수 있음
  * `@Version` 사용 시, 충돌이 잦아지면 성능 저하 가능성
  * 비관적 락 시도시 락 대기 시간 초과로 인한 예외 발생 가능성
* 고도화로 RDB에서 레디스 등으로 좌석 점유 여부 확인 로직과 대기열 로직 이관할 경우 UNIQUE 제약 적용 어려움
* 주요하지 않은 시나리오가 하나의 트랜잭션에 묶여 있음
  * 예: 좌석 예약 시 결제-예약과 토큰 만료가 하나의 트랜잭션으로 묶임
  * 추후 이벤트 기반 처리로 분리 필요

## 6. 결론 (Conclusion)

* **요약**: 각 시나리오별 최적 메커니즘 적용으로 안정성·성능 확보
